<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catacomb Map - etinuXe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: #0c0c0c;
            color: #ffffff;
            zoom: 67%;
            overflow: hidden;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .header {
            margin-bottom: 20px;
        }
        .header h1 {
            font-size: 48px;
            margin-bottom: 8px;
            color: #8654d8;
        }
        .header p {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.7);
        }
        .map-container {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            margin-bottom: 20px;
        }
        #map3d {
            width: 100%;
            height: 100%;
        }
        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid rgba(134, 84, 216, 0.3);
        }
        .legend h3 {
            font-size: 16px;
            margin-bottom: 12px;
            color: #8654d8;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 16px;
            border-radius: 8px;
            font-size: 14px;
            border: 1px solid rgba(134, 84, 216, 0.3);
        }
        .back-button {
            display: inline-block;
            padding: 12px 24px;
            background: rgba(134, 84, 216, 0.1);
            border: 1px solid #8654d8;
            border-radius: 8px;
            color: #ffffff;
            text-decoration: none;
            transition: background 0.2s;
        }
        .back-button:hover {
            background: rgba(134, 84, 216, 0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Catacomb Map</h1>
            <p>3D Underground City Navigation</p>
        </div>

        <div class="map-container">
            <canvas id="map3d"></canvas>

            <div class="legend">
                <h3>Safety Zones</h3>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4444ff;"></div>
                    <span>Safe Zone</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff9944;"></div>
                    <span>Cautious</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff4444;"></div>
                    <span>Danger</span>
                </div>
            </div>

            <div class="controls">
                <div>Drag: Rotate view</div>
                <div>Scroll: Zoom in/out</div>
            </div>
        </div>

        <a href="index.html" class="back-button">‚Üê Back to Home</a>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const canvas = document.getElementById('map3d');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.Fog(0x0a0a0a, 30, 80);

        const camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
        camera.position.set(25, 25, 25);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.shadowMap.enabled = true;

        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(20, 30, 20);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        const pointLight1 = new THREE.PointLight(0x8654d8, 1, 50);
        pointLight1.position.set(0, 10, 0);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0x4444ff, 0.5, 30);
        pointLight2.position.set(-10, 5, -10);
        scene.add(pointLight2);

        const pointLight3 = new THREE.PointLight(0xff4444, 0.5, 30);
        pointLight3.position.set(10, 5, 10);
        scene.add(pointLight3);

        const floorGeometry = new THREE.PlaneGeometry(60, 60, 20, 20);
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.8,
            metalness: 0.2,
            wireframe: false
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        const vertices = floorGeometry.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
            vertices[i + 2] = Math.random() * 0.5 - 0.25;
        }
        floorGeometry.attributes.position.needsUpdate = true;
        floorGeometry.computeVertexNormals();

        function createRoom(x, y, z, width, height, depth, color, name, glowIntensity = 0.3) {
            const group = new THREE.Group();

            const wallThickness = 0.3;
            const walls = [
                { w: width, h: height, d: wallThickness, x: 0, y: 0, z: -depth/2 },
                { w: width, h: height, d: wallThickness, x: 0, y: 0, z: depth/2 },
                { w: wallThickness, h: height, d: depth, x: -width/2, y: 0, z: 0 },
                { w: wallThickness, h: height, d: depth, x: width/2, y: 0, z: 0 }
            ];

            walls.forEach(wall => {
                const geometry = new THREE.BoxGeometry(wall.w, wall.h, wall.d);
                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.4,
                    metalness: 0.6,
                    emissive: color,
                    emissiveIntensity: glowIntensity
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(wall.x, wall.y, wall.z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                group.add(mesh);

                const edges = new THREE.EdgesGeometry(geometry);
                const line = new THREE.LineSegments(
                    edges,
                    new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true })
                );
                line.position.copy(mesh.position);
                group.add(line);
            });

            const ceilingGeometry = new THREE.BoxGeometry(width, 0.2, depth);
            const ceilingMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a2a,
                roughness: 0.7,
                metalness: 0.3
            });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.position.y = height / 2;
            ceiling.castShadow = true;
            group.add(ceiling);

            group.position.set(x, y, z);
            scene.add(group);
            return group;
        }

        function createTunnel(x1, z1, x2, z2, y = 1) {
            const dx = x2 - x1;
            const dz = z2 - z1;
            const length = Math.sqrt(dx * dx + dz * dz);
            const angle = Math.atan2(dz, dx);

            const geometry = new THREE.BoxGeometry(length, 2, 2);
            const material = new THREE.MeshStandardMaterial({
                color: 0x3a3a3a,
                roughness: 0.8,
                metalness: 0.2
            });
            const tunnel = new THREE.Mesh(geometry, material);
            tunnel.position.set((x1 + x2) / 2, y, (z1 + z2) / 2);
            tunnel.rotation.y = angle;
            tunnel.castShadow = true;
            tunnel.receiveShadow = true;
            scene.add(tunnel);

            const pipeGeometry = new THREE.CylinderGeometry(0.15, 0.15, length, 8);
            const pipeMaterial = new THREE.MeshStandardMaterial({
                color: 0x666666,
                roughness: 0.3,
                metalness: 0.8
            });
            const pipe = new THREE.Mesh(pipeGeometry, pipeMaterial);
            pipe.position.set((x1 + x2) / 2, y + 1.2, (z1 + z2) / 2);
            pipe.rotation.z = Math.PI / 2;
            pipe.rotation.y = angle;
            scene.add(pipe);
        }

        createRoom(-10, 3, -10, 8, 6, 8, 0x4444ff, 'Safe Zone A', 0.2);
        createRoom(10, 3, -10, 7, 6, 7, 0x4444ff, 'Safe Zone B', 0.2);
        createRoom(-10, 3, 10, 7, 6, 7, 0xff9944, 'Cautious Area', 0.4);
        createRoom(10, 3, 10, 8, 6, 8, 0xff4444, 'Danger Zone', 0.6);
        createRoom(0, 2.5, 0, 6, 5, 6, 0x8654d8, 'Central Hub', 0.5);

        createTunnel(-10, -10, 0, 0);
        createTunnel(10, -10, 0, 0);
        createTunnel(-10, 10, 0, 0);
        createTunnel(10, 10, 0, 0);

        for (let i = 0; i < 30; i++) {
            const rockGeometry = new THREE.DodecahedronGeometry(Math.random() * 0.5 + 0.2, 0);
            const rockMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a4a4a,
                roughness: 0.9,
                metalness: 0.1
            });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            rock.position.set(
                Math.random() * 50 - 25,
                0.2,
                Math.random() * 50 - 25
            );
            rock.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            rock.castShadow = true;
            scene.add(rock);
        }

        let mouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationY = 0;
        let targetRotationX = 0;

        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!mouseDown) return;

            const deltaX = e.clientX - mouseX;
            const deltaY = e.clientY - mouseY;

            targetRotationY += deltaX * 0.005;
            targetRotationX += deltaY * 0.005;
            targetRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotationX));

            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 1.05 : 0.95;
            camera.position.multiplyScalar(delta);
            camera.position.clampLength(10, 60);
        });

        window.addEventListener('resize', () => {
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        });

        function animate() {
            requestAnimationFrame(animate);

            const radius = camera.position.length();
            camera.position.x = radius * Math.sin(targetRotationY) * Math.cos(targetRotationX);
            camera.position.y = radius * Math.sin(targetRotationX);
            camera.position.z = radius * Math.cos(targetRotationY) * Math.cos(targetRotationX);
            camera.lookAt(0, 2, 0);

            pointLight1.intensity = 1 + Math.sin(Date.now() * 0.001) * 0.3;

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
